# URL Management Refactoring

This document explains the URL management refactoring that was implemented to address issues with hard-coded URLs, port inconsistencies, and complex environment variable management in the authentication workflow.

## Overview of Changes

The refactoring focused on creating a more consistent, maintainable approach to URL management across all services:

1. Created a centralized configuration system with clear separation of environments
2. Standardized internal (service-to-service) and external (browser-to-service) URLs
3. Fixed inconsistent Keycloak auth paths
4. Simplified URL generation and port management
5. Updated all services to use the new URL management approach

## New Configuration Structure

The new configuration system uses a layered approach:

### Base Configuration (`.env.base`)

Contains shared configuration across all environments:
- Database credentials
- Authentication settings
- Internal port numbers
- Service names

### Environment-Specific Configuration (`.env.{environment}`)

Environment-specific settings for development, staging, and production:
- Base domain names
- Protocol settings (HTTP/HTTPS)
- External ports
- CORS settings

### Derived Configuration (generated by `scripts/generate-config.sh`)

A combined `.env` file with all configuration, including derived URLs:
- Internal URLs (service-to-service): `INTERNAL_*_URL`
- External URLs (browser-to-service): `PUBLIC_*_URL`

## How to Use the New System

### Switching Environments

1. Run the configuration generator with the desired environment:
   ```bash
   ENVIRONMENT=development ./scripts/generate-config.sh
   ```

2. Restart your services:
   ```bash
   docker-compose down
   docker-compose up -d
   ```

### Adding a New Service

1. Add service configuration to `.env.base`
2. Add domain/port configuration to each environment file
3. Update the generator script to include the new service URLs
4. Run the generator to update the configuration

### URLs and Port Management

The system automatically handles port formatting in URLs:
- For HTTP, standard port 80 is omitted
- For HTTPS, standard port 443 is omitted
- Non-standard ports are included in the URL

## Naming Conventions

- `INTERNAL_*_URL`: For container-to-container communication
  - Format: `http://<service-name>:<port>`
  - Example: `INTERNAL_KEYCLOAK_URL=http://keycloak:8080`

- `PUBLIC_*_URL`: For browser-to-service communication
  - Format: `https://<domain>.<base-domain>[:<port>]`
  - Example: `PUBLIC_KEYCLOAK_URL=https://keycloak.dive25.local`

- Service-specific auth paths:
  - `*_AUTH_URL`: URL with authentication path
  - Example: `PUBLIC_KEYCLOAK_AUTH_URL=https://keycloak.dive25.local/auth`

## Authentication Flow

The authentication workflow now follows a clear pattern:

1. Browser requests → Kong proxy → Frontend app
2. Frontend app uses PUBLIC_KEYCLOAK_AUTH_URL for authentication
3. Kong communicates with Keycloak using INTERNAL_KEYCLOAK_AUTH_URL
4. API validates tokens using standardized URLs

## Troubleshooting

If you encounter URL-related issues:

1. Run `./scripts/generate-config.sh` to regenerate the configuration
2. Check the `.env` file for correct URL generation
3. Verify that the proper URLs are being used for internal vs. external communication
4. Check container logs for connection errors

## Testing the Authentication Flow

To test the refactored authentication flow:

1. Generate the configuration for development:
   ```bash
   ENVIRONMENT=development ./scripts/generate-config.sh
   ```

2. Start the services:
   ```bash
   docker-compose up -d
   ```

3. Try accessing the frontend at the appropriate public URL
4. Monitor logs for authentication-related messages
5. Test API endpoints requiring authentication

## Future Improvements

The following improvements could be made to further enhance the system:

1. Service discovery using DNS-based resolution
2. Health checks to verify URL accessibility
3. Configuration validation before service startup
4. Integration with a configuration management system 